# LUMA Scheduling System

## Overview

LUMA supports two modes of interview scheduling:

1. **Manual scheduling** — recruiters create/edit/delete interviews by hand via a modal form on the schedule pages. Calls `createInterview` / `updateInterview` / `deleteInterview` from `supabase.ts`.

2. **Algorithm-based scheduling** — platform admins configure an auto-scheduling algorithm per org (or per job posting) from the admin panel. The algorithm runs in the browser for a dry-run preview, then bulk-inserts proposed interviews on confirmation.

This document covers the algorithm-based system.

---

## Design Goals

1. **Pluggable** — new algorithms can be added without touching the scheduler runner
2. **Transparent** — admins preview what the algorithm will do before committing (dry-run)
3. **Safe** — auto-scheduling never overwrites manually-created interviews
4. **Org-scoped** — each org (or job posting) can use a different algorithm
5. **No external infra** — algorithms run in the browser or in a Supabase Edge Function; no separate service

---

## Architecture

Algorithms are **pure TypeScript modules** in `src/lib/scheduling/algorithms/`. Each exports a function with a standard interface. The same modules work in the browser (for previews) and in an Edge Function (for cron-triggered scheduling).

```
src/lib/scheduling/
  types.ts                          — shared types and interfaces
  registry.ts                       — exports all available algorithms
  utils.ts                          — shared helpers (time overlap, slot generation)
  algorithms/
    greedy-first-available.ts
    balanced-load.ts
    round-robin.ts
```

---

## Algorithm Interface

```typescript
export interface SchedulerInput {
  applicants: {
    email: string;
    name: string;
    jobId: number;
    availability: TimeRange[];
  }[];
  interviewers: {
    email: string;
    availability: TimeRange[];
  }[];
  existingInterviews: {
    startTime: string;
    endTime: string;
    interviewer: string;
    applicant: string;
  }[];
  config: SchedulerConfig;
}

export interface SchedulerConfig {
  slotDurationMinutes: number;
  breakBetweenMinutes: number;
  maxInterviewsPerInterviewer: number;
  interviewType: 'individual' | 'group';
  groupSize?: number;
  location: string;
  [key: string]: unknown;  // algorithm-specific params
}

export interface SchedulerOutput {
  interviews: ProposedInterview[];
  unmatched: string[];   // applicant emails that couldn't be scheduled
  warnings: string[];
}

export interface ProposedInterview {
  startTime: string;
  endTime: string;
  applicant: string;
  interviewer: string;
  location: string;
  type: 'individual' | 'group';
  jobId: number;
}

export interface TimeRange {
  date: string;   // YYYY-MM-DD
  start: string;  // HH:mm
  end: string;    // HH:mm
}

// Every algorithm exports this shape
export interface SchedulingAlgorithm {
  id: string;
  name: string;
  description: string;
  configSchema: ConfigField[];
  run: (input: SchedulerInput) => SchedulerOutput;
}

export interface ConfigField {
  key: string;
  label: string;
  type: 'number' | 'string' | 'boolean' | 'select';
  default: unknown;
  options?: { label: string; value: unknown }[];
}
```

---

## Built-in Algorithms

### `greedy-first-available`
Sorts applicants by submission date, then for each applicant finds the first overlapping slot with any available interviewer. Simple, fast, predictable. Best for small orgs or straightforward scheduling.

### `balanced-load`
Same matching logic as greedy, but prioritizes the interviewer with the fewest assigned interviews who has an overlapping slot. Best for orgs with many interviewers who want fair workload distribution.

### `round-robin`
Cycles through interviewers in a fixed order. Each interviewer gets the next available applicant in sequence; skips if no overlapping availability. Best for orgs that want strict rotation.

### `batch-scheduler`
Designed for large cohorts (100s of applicants) across multiple rooms and multiple rounds. Generates all possible time slots from session windows × rooms, fills them with applicants based on availability (most-constrained first), and provides structured output for applicants the algorithm misses. See [Batch Scheduler](#batch-scheduler-1) below for full details.

### `custom` (future)
Admin pastes a JS function body into a code editor in the browser. The function receives `SchedulerInput` and must return `SchedulerOutput`. Runs sandboxed. For power users with unique constraints.

---

## Database

### `scheduling_config`

Stores per-org or per-job scheduling preferences.

```sql
CREATE TABLE public.scheduling_config (
  id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  created_at timestamptz NOT NULL DEFAULT now(),
  org_id bigint NOT NULL REFERENCES organizations(id) ON DELETE CASCADE,
  job_id bigint REFERENCES job_posting(id) ON DELETE CASCADE,
  algorithm_id text NOT NULL DEFAULT 'greedy-first-available',
  config jsonb NOT NULL DEFAULT '{}',
  last_run_at timestamptz,
  last_run_result jsonb,
  UNIQUE (org_id, job_id)
);
```

`job_id = NULL` means org-wide default. `config` stores algorithm-specific parameters. `last_run_result` summarizes the most recent run.

### `interviewer_availability`

Interviewers submit their available windows (mirrors applicant availability).

```sql
CREATE TABLE public.interviewer_availability (
  id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  created_at timestamptz NOT NULL DEFAULT now(),
  org_id bigint NOT NULL REFERENCES organizations(id) ON DELETE CASCADE,
  user_id uuid NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  email text NOT NULL,
  date date NOT NULL,
  start_time time NOT NULL,
  end_time time NOT NULL,
  timezone text NOT NULL DEFAULT 'America/New_York',
  UNIQUE (org_id, user_id, date, start_time)
);
```

### `interviews.source`

Track whether an interview was manually created or auto-scheduled:

```sql
ALTER TABLE public.interviews
  ADD COLUMN source text NOT NULL DEFAULT 'manual';
  -- values: 'manual' | 'auto'
```

Auto-scheduling only inserts interviews with `source = 'auto'`. The "Clear" button only deletes `source = 'auto'` rows — manual interviews are never touched.

---

## Admin UI

Located at `/admin` under a "Scheduling" tab.

### Per-Org Config Panel

1. Org selector
2. Algorithm picker — radio cards showing `name` and `description` from the registry
3. Config form — dynamically rendered from `configSchema` (numbers, selects, toggles)
4. Save — writes to `scheduling_config`

### Dry-Run / Preview

1. **Preview** — fetches applicants + interviewer availability for the selected org/job, runs the algorithm in the browser, displays:
   - Proposed interviews (applicant, interviewer, time, location)
   - Unmatched applicants
   - Warnings
2. **Apply** — bulk-inserts proposed interviews with `source = 'auto'`
3. **Clear Auto-Scheduled** — deletes all `source = 'auto'` interviews for the org/job

---

## Interviewer Availability Input

The recruiter's **My Schedule** page (`/private/[slug]/availability`) includes an `AvailabilityGrid` component (same one applicants use) where interviewers submit their available windows. On save, rows are written to `interviewer_availability`.

---

## Edge Function (Optional)

For orgs that want cron-triggered auto-scheduling:

```
supabase/functions/auto-schedule/index.ts
```

- Reads `scheduling_config` for orgs with an algorithm set
- Imports the same algorithm modules
- Runs the algorithm, inserts interviews with `source = 'auto'`
- Triggered by Supabase cron or `pg_cron`

This is optional — the browser-based dry-run covers the primary use case.

---

---

## Batch Scheduler

The `batch-scheduler` algorithm handles large-scale scheduling across many rooms and multiple rounds.

### When to use it

- 50+ applicants
- Multiple rooms available simultaneously (e.g. 10 MCB rooms)
- Multiple interview rounds (e.g. individual + group)
- Need structured output for applicants who couldn't be auto-placed

### Config

```json
{
  "rooms": ["MCB230", "MCB231", "MCB232", "MCB233", "MCB304"],
  "rounds": [
    {
      "id": "individual",
      "label": "Individual Interview",
      "type": "individual",
      "durationMinutes": 20,
      "breakBeforeMinutes": 0,
      "groupSize": 1,
      "interviewersPerRoom": 1
    },
    {
      "id": "group",
      "label": "Group Interview",
      "type": "group",
      "durationMinutes": 40,
      "breakBeforeMinutes": 10,
      "groupSize": 8,
      "interviewersPerRoom": 3
    }
  ],
  "sessionWindows": [
    { "date": "2025-09-13", "startTime": "09:00", "endTime": "17:00" },
    { "date": "2025-09-14", "startTime": "09:00", "endTime": "13:00" }
  ],
  "slotStepMinutes": 15,
  "blockBreakMinutes": 5,
  "requireAllRounds": false
}
```

**Config fields:**

| Field | Type | Description |
|---|---|---|
| `rooms` | `string[]` | Room names — all rooms are used in parallel |
| `rounds` | `BatchRound[]` | Ordered list of rounds; each round is scheduled independently |
| `sessionWindows` | `BatchSessionWindow[]` | Date + time windows when scheduling can happen |
| `slotStepMinutes` | `number` | How often slot start times are generated (e.g. every 15 min) |
| `blockBreakMinutes` | `number` | Gap between sequential slots in the same room |
| `requireAllRounds` | `boolean` | If `true`, applicants missing any round have ALL their assignments removed |

**`BatchRound` fields:**

| Field | Description |
|---|---|
| `id` | Unique identifier (e.g. `"individual"`, `"group-1"`) |
| `label` | Display name |
| `type` | `"individual"` or `"group"` |
| `durationMinutes` | Length of each slot |
| `breakBeforeMinutes` | Gap before this round starts (within the same session block) |
| `groupSize` | Applicants per slot (`1` for individual, `N` for group) |
| `interviewersPerRoom` | Interviewers assigned to each slot |

### How it works

1. **Slot generation** — For each session window × room × round, the algorithm generates all possible time slots spaced `slotStepMinutes` apart.

2. **Interviewer assignment** — Each slot gets `interviewersPerRoom` interviewers assigned based on their availability. If an interviewer has no availability data, they're treated as always available. If fewer interviewers than needed are available, the algorithm falls back to round-robin from the full list and emits a warning.

3. **Applicant matching** — For each round, applicants are sorted by constraint score (fewest available slots first — most constrained matched first). Each applicant is placed in the first slot with remaining capacity where they're available and have no time conflicts.

4. **Missed applicants** — Applicants who couldn't be placed receive a `SuggestedSlot[]` listing every slot they *could* attend (including full slots, marked `isFull: true`). Recruiters can use this to manually override.

5. **`requireAllRounds`** — If `true`, any applicant missing one or more rounds has all their assignments removed, so the output is all-or-nothing per applicant.

### Output

In addition to the standard `SchedulerOutput` fields, the batch scheduler populates:

**`unmatchedDetails`** (`UnmatchedApplicant[]`):
```typescript
{
  email: "student@vt.edu",
  name: "Jane Smith",
  missedRounds: ["individual"],   // which round(s) they couldn't be placed in
  suggestedSlots: [
    {
      roundId: "individual",
      date: "2025-09-13",
      startTime: "14:00",
      endTime: "14:20",
      room: "MCB232",
      isFull: false              // false = space available; true = recruiter must bump someone
    }
  ]
}
```

**`stats`** (`BatchRoundStat[]`):
```typescript
{
  roundId: "individual",
  roundLabel: "Individual Interview",
  scheduled: 243,
  missed: 7,
  totalSlots: 300,
  filledSlots: 180
}
```

### Interview rows in the database

Following the same model as the existing Archimedes data: each (applicant × interviewer) in a slot produces **one row** in the `interviews` table. So a group slot with 8 applicants and 3 interviewers produces 24 rows — all with the same `startTime`, `endTime`, and `location`, enabling per-interviewer evaluations per applicant.

---

## Implementation Status

- [x] **Phase A — Foundation**: `types.ts`, `registry.ts`, `utils.ts`, `greedy-first-available`, `balanced-load`, `round-robin`, `batch-scheduler` implemented
- [ ] **Phase B — Admin UI**: Scheduling tab in admin panel, dry-run preview, apply/clear buttons
- [ ] **Phase C — Interviewer Availability**: `AvailabilityGrid` on My Schedule, `interviewer_availability` CRUD, wire into scheduler input
- [ ] **Phase D — More Algorithms**: `custom` JS editor for power users
- [ ] **Phase E — Edge Function**: Cron-triggered auto-scheduling, admin toggle per org

---

## Open Questions

1. **Applicant availability** — currently stored as JSON inside `recruitInfo`. Should it be extracted into a dedicated `applicant_availability` table for easier querying?
2. **Group interviews** — how should the algorithm handle multiple applicants per slot? Config toggle or separate algorithm?
3. **Notifications** — should auto-scheduling trigger email notifications? (Requires email integration.)
4. **Timezone handling** — all times stored in UTC and converted on display, or stored with timezone offset?
